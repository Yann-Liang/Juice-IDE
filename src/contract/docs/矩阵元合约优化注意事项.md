JUICE 智能合约优化方案注意事项
---
----------

DT : 2017-10-11 16:05:32


### 文档目的

提醒相关开发人员在进行合约性能优化方案更改时需要注意事项。

### 阅读对象
 
合约开发者

### 参考文献

N/A
  
### 文档背景

  现有系统对于字符串的处理比较消耗性能，某些环境下可能导致系统不可正常使用。经过方案制定后采用新的方式进行字符串优化处理。
  
### 方案简介

 * 目标：字符串处理更高效
 * 方式：使用**栈**方式处理


### 详细方案

#### LibStack.sol 优化

> 详细函数变动参考代码中注释

```js
library LibStack {

    // 更新：原有返回类型为bool，先更改为uint
    function push(string _data) internal constant returns(uint _len) {
    }
    
    function pop() internal constant returns(string _ret) {
    }
    
    // 新扩展函数，传入指定要出栈的元素长度
    function popex(uint _len) internal constant returns(string) {
    }

    function top() internal constant returns(string _ret) {
    }
    
    // 新扩展函数，传入指定要出栈的元素长度
    function topex(uint _len) internal constant returns(string _ret) {
    }

    function size() internal constant returns(uint _ret) {
    }
    
    function clear() internal constant returns(uint _ret) {
    }

    // 更改返回类型：原bool类型，变更为uint
    function append(string _data) internal constant returns(uint _len) {
    }

    // 更改返回类型：原bool类型，变更为uint
    function appendKeyValue(string _key, string _val) internal constant returns (uint _len) {
    }

    // 更改返回类型：原bool类型，变更为uint
    function appendKeyValue(string _key, uint _val) internal constant returns (uint _len) {  
    }

    // 更改返回类型：原bool类型，变更为uint
    function appendKeyValue(string _key, int _val) internal constant returns (uint _len) {
    }
    
    // 更改返回类型：原bool类型，变更为uint
    function appendKeyValue(string _key, address _val) internal constant returns (uint _len) {
    }
}
```

变动说明：
1、返回类型更改：所有涉及到原来使用返回类型作为：参数、条件、入参等场景，必须进行更改，原来的bool类型更改为了uint，对应的使用需要进行更新。   
 
2、新增函数：在LibStack库中新增了几个后缀为ex的函数，主要是为保留对老版本进行兼容处理，而非直接替换原有的函数逻辑。相关对栈的使用都需要使用新的函数，如：popex();topex();


#### 更改后用法示例
```js
// 示例01
function listAll() constant private returns(string _json) {
        uint len = 0;
        len = LibStack.push("{");
        len = LibStack.appendKeyValue("nodeId","00000");
        len = LibStack.append("}");
        _json = LibStack.popex(len);
}

// 示例02
function listAll() constant private returns(string _json) {
        uint len = 0;
        len = LibStack.push("{");
        len = LibStack.appendKeyValue("ret", uint(0));
        // 注意：在appendKeyValue后面执行append追加k-v对，不会自动添加逗号，需要显示指定
        len = LibStack.append(",\"data\":{");
        len = LibStack.appendKeyValue("total", tatal);
        len = LibStack.append(",\"items\":[]");
        _json = LibStack.popex(len);
}

// 示例03
function listAll() constant private returns(string _json) {
        uint len = 0;
        len = LibStack.push("{");
        len = LibStack.appendKeyValue("ret", uint(0));
        len = LibStack.append(",\"data\":{}");
        len = LibStack.append(",\"items\":[]");
        // 注意：此处appendKeyValue在append后面，会自动携带逗号
        len = LibStack.appendKeyValue("total", total);
        len = LibStack.append("}}");
        _json = LibStack.popex(len);
}
```

注意事项：    
1、每个栈开始使用的第一句必须为：```push()```操作，开栈，如果没有需要指定的元素则push空字符串。每次追加元素后记录返回最新的元素长度，最后使用```popex(len)```出栈；    

2、请对比示例02和示例03的差异，注意此处为特别注意事项；


### 优化方案续集 - LibJson 改造
```js
pragma solidity ^0.4.2;

library LibJson {

    function isJson(string _json) internal constant returns(bool _ret) {
    }

    function jsonRead(string _json, string _keyPath) internal constant returns(string _ret) {
    }

    function jsonKeyExists(string _json, string _keyPath) internal constant returns(bool _ret) {        
    }
    
    // 新增：返回类型为uint
    function jsonKeyExistsEx(string _json, string _keyPath) internal constant returns(uint _len) {
    }

    // 新增函数：json使用前先进行push操作
    function push(string _json) internal constant returns(uint _len) {   
    }
    
    // 新增函数
    function pop() internal constant {
    }

    // 新增函数
    function size() internal constant returns(uint _ret) {
    }
    
    // 新增函数
    function clear() internal constant {
    }
} 

```

说明：LibJson库的主要调整在于新增了```push()``` 、```pop()```、```size()```、```clear()```新的功能函数，因此此函数的改动需要调整所有的业务合约进行更改，一旦升级则**不兼容**以前用法；


用法示例

```js
// 示例01
function fromJsonArrayEx(JsonTestST[] storage _self, string _json) internal returns(bool succ) {//需实现的函数4
        // 在对json字符串进行操作时（读取/判断），先进行push()函数调用
        LibJson.push(_json);
        _self.length = 0;

        if (!_json.isJson()) {
            // 与push()成对出现，当json字符串在栈中不使用后必须进行pop操作
            LibJson.pop();
            return false;
        }

        while (true) {
            string memory key = "[".concat(_self.length.toString(), "]");
            if (!_json.jsonKeyExists(key))
                break;
            _self.length++;
            _self[_self.length-1].fromJsonEx(_json.jsonRead(key));
        }
        // 与push()成对出现，当json字符串在栈中不使用后必须进行pop操作
        LibJson.pop();
        return true;
    }

// 示例02
function fromJson(JsonTestST storage _self, string _json) internal returns(bool) {
        LibJson.push(_json);
        _self.fa0 = _json.jsonRead("fa0");
        _self.fa1 = _json.jsonRead("fa1").toUint();
        _self.fa2 = _json.jsonRead("fa2").toAddress();
        LibJson.pop();
        return true;
    }
```

说明：所有对json的操作之前必须进行```push```操作，当操作完成后或者提前结束，必须使用```pop```来清空当前json串在栈中的位置；
